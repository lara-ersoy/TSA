import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize  # Allowed for numerical optimization

def preparing_AR2_data(log_returns):
    """
    Creating base for the AR(2) model
    """
    r = log_returns.values
    n = len(r)

    # Base X & y
    X, y = [], []
    for t in range(2, n):
        X.append([1, r[t-1], r[t-2]]) 
        y.append(r[t])

    X = np.array(X)
    y = np.array(y)
    return X, y

def estimating_AR2_ols(log_returns):
    """
    Estimating the AR(2) parameters phi0, phi1, phi2 by OLS-estimation
    """
    X, y = preparing_AR2_data(log_returns)

    # OLS formula: beta = (X^T*X)^{-1}*(X^T*y)
    beta = np.linalg.inv(X.T @ X) @ (X.T @ y)
    phi0, phi1, phi2 = beta
    return phi0, phi1, phi2

def negative_log_likelihood_AR2(params, r):
    """
    Negative log-likelihood for the AR(2) model with Gaussian errors
    """
    phi0, phi1, phi2, sigma2 = params

    # Sigma must be positive; if not, return a fault
    if sigma2 <= 0:
        return np.inf

    residuals = []
    for t in range(2, len(r)):
        r_t = r[t]
        r_t1 = r[t-1]
        r_t2 = r[t-2]
        residuals.append(r_t - (phi0 + phi1*r_t1 + phi2*r_t2))

    residuals = np.array(residuals)
    n = len(residuals)
    RSS = np.sum(residuals**2)

    # Negative log-likelihood (the Gaussian)
    # Minimizing the negative log-likelihood
    nll = 0.5 * n * np.log(2 * np.pi * sigma2) + 0.5 * (RSS / sigma2)
    return nll

def estimating_AR2_mle(log_returns):
    """
    Estimating the AR(2) parameters phi0, phi1, phi2 using MLE-estimation
    """
    r = log_returns.values

    # Initial guesses for phi0, phi1, phi2, and sigma2
    phi0_guess = 0.0
    phi1_guess = 0.0
    phi2_guess = 0.0
    sigma2_guess = np.var(r)  # naive guess
    init_params = [phi0_guess, phi1_guess, phi2_guess, sigma2_guess]

    # Using optimization to minimize the negative log-likelihood
    result = minimize(
        negative_log_likelihood_AR2,
        init_params,
        args=(r,),
        method='BFGS',
        options={'disp': False}
    )

    phi0_mle, phi1_mle, phi2_mle, sigma2_mle = result.x
    return phi0_mle, phi1_mle, phi2_mle, sigma2_mle

def forecasting_AR2(phi0, phi1, phi2, log_returns, steps=5):
    """
    Forecasting using AR(2) model
    """
    r_T = log_returns.iloc[-1]       # r_T
    r_T_lagged = log_returns.iloc[-2]  # r_{T-1}
    forecasts = []

    for _ in range(steps):
        r_new = phi0 + phi1*r_T + phi2*r_T_lagged
        forecasts.append(r_new)
        # Shift for next iteration
        r_T_lagged, r_T = r_T, r_new

    return np.array(forecasts)

def main():
    # Read data
    df = pd.read_csv("FVX_data.csv", index_col=0, parse_dates=True)
    df.columns = ["Price"]  
    df.index = pd.to_datetime(df.index, errors="coerce")

    # Ensuring price column is numeric
    df["Price"] = pd.to_numeric(df["Price"], errors="coerce")
    df.dropna(subset=["Price"], inplace=True)

    # Compute log-returns
    df["log_ret"] = np.log(df["Price"] / df["Price"].shift(1))
    df.dropna(inplace=True)

    # Splitting data: last 20 data points for testing, the rest for training
    df_train = df.iloc[:-20].copy()
    df_test = df.iloc[-20:].copy()

    # Estimating AR(2) using OLS on the training set
    phi0_ols, phi1_ols, phi2_ols = estimating_AR2_ols(df_train["log_ret"])
    print(f"AR(2) OLS estimates (Training set):")
    print(f"phi0 = {phi0_ols:.5f}, phi1 = {phi1_ols:.5f}, phi2 = {phi2_ols:.5f}")

    # Estimating AR(2) using MLE on the training set
    phi0_mle, phi1_mle, phi2_mle, sigma2_mle = estimating_AR2_mle(df_train["log_ret"])
    print(f"\nAR(2) MLE estimates (Training set):")
    print(f"phi0 = {phi0_mle:.5f}, phi1 = {phi1_mle:.5f}, phi2 = {phi2_mle:.5f}, sigma2 = {sigma2_mle:.5f}")

    # Forecast the next 20 steps from the training set
    steps_ahead = len(df_test)  # 20
    forecast_vals_ols = forecasting_AR2(phi0_ols, phi1_ols, phi2_ols, df_train["log_ret"], steps=steps_ahead)
    forecast_vals_mle = forecasting_AR2(phi0_mle, phi1_mle, phi2_mle, df_train["log_ret"], steps=steps_ahead)

    print(f"\n(OLS) Forecasted log-returns for the next {steps_ahead} days:")
    for i, val in enumerate(forecast_vals_ols, start=1):
        print(f"Day {i}: {val:.5f}")

    print(f"\n(MLE) Forecasted log-returns for the next {steps_ahead} days:")
    for i, val in enumerate(forecast_vals_mle, start=1):
        print(f"Day {i}: {val:.5f}")

    # Plotting the training set, the test set, and the forecasts
    plt.figure(figsize=(10, 5))
    plt.plot(df_train["log_ret"], label="Training log-returns")
    plt.plot(df_test["log_ret"], label="Test log-returns (actual)", color="gray")

    # Date range for the forecast from the last train date
    forecast_index = pd.date_range(
        start=df_train.index[-1] + pd.Timedelta(days=1),
        periods=steps_ahead,
        freq='B'
    )

    # Plot OLS vs MLE forecasts
    plt.plot(forecast_index, forecast_vals_ols, 'ro--', label="OLS forecast")
    plt.plot(forecast_index, forecast_vals_mle, 'go--', label="MLE forecast")

    plt.title("AR(2) Model - Train/Test split (20 points) - OLS vs MLE")
    plt.legend()
    plt.show()

if __name__ == "__main__":
    main()
