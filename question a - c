import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yfin
from scipy.optimize import minimize

# PART 2 (a) - Loading in data and compute log returns
df = yfin.download("^TNX", start="2010-01-01", end="2023-12-31")
df['Log_Returns'] = np.log(df['Close'] / df['Close'].shift(1))
df.dropna(inplace=True)
print(df[['Close', 'Log_Returns']].head())

# PART 2 (b) - Estimating AR(p) models for p = 1, 2, 3, 4, 5

def estimating_ar_model(y, p):
    X = np.column_stack([y.shift(i) for i in range(1, p+1)])
    X = np.hstack([np.ones((X.shape[0], 1)), X])  # Adding intercept
    y = y[p:]  # Dependent variable
    X = X[p:, :]  # Independent variables
    
    beta = np.linalg.inv(X.T @ X) @ X.T @ y  # OLS estimation formula
    residuals = y - X @ beta
    sigma2 = np.var(residuals)
    log_llh = -0.5 * len(y) * np.log(2 * np.pi * sigma2) - (residuals @ residuals) / (2 * sigma2)
    
    n = len(y)  # Sample size
    k = len(beta)  # Number of parameters
    
    aic = -2 * log_llh + 2 * k
    bic = -2 * log_llh + k * np.log(n)  # Compute BIC

    return log_llh, aic, bic

# Compute values for p = 1, 2, 3, 4, 5
results = {"p": [], "Log Likelihood": [], "AIC": [], "BIC": []}

for p in range(1, 6):
    ll, aic, bic = estimating_ar_model(df['Log_Returns'], p)
    results["p"].append(p)
    results["Log Likelihood"].append(ll)
    results["AIC"].append(aic)
    results["BIC"].append(bic)

# Convert results to a df and display
bic_df = pd.DataFrame(results)
print(bic_df)

# PART 2 (c) - Rolling the window forecastingwith the size of 750 observations
def rolling_window_forecast(y, p, window=750):
    forecasts = []
    actuals = []
    
    for i in range(window, len(y)):
        train = y[i-window:i]
        _, _, beta = estimating_ar_model(train, p)
        X_new = np.hstack([1, train[-p:].values[::-1]])  # Preparing new input
        forecast = X_new @ beta
        forecasts.append(forecast)
        actuals.append(y.iloc[i])
    
    forecasts = np.array(forecasts)
    actuals = np.array(actuals)
    rmse = np.sqrt(np.mean((forecasts - actuals) ** 2))
    
    return forecasts, actuals, rmse

# Generateing rolling forecast for different AR orders
rmse_results = {}

for p in range(1, 6):
    forecasts, actuals, rmse = rolling_window_forecast(df['Log_Returns'], p)
    rmse_results[p] = rmse
    
    # Plot actual vs forecast
    plt.figure(figsize=(10, 5))
    plt.plot(actuals, label='Actual', color='lightblue')
    plt.plot(forecasts, label=f'AR({p}) forecast', linestyle='dashed', color='fuchsia')
    plt.xlabel("Time")
    plt.ylabel("Log returns")
    plt.title(f"Rolling window forecast for AR({p})")
    plt.legend()
    plt.savefig(f"rolling_forecast_ar{p}.png")
    plt.close()  # This prevents display issues


# Printing RMSE results
print("RMSE values for different AR models:")
for p, rmse in rmse_results.items():
    print(f"AR({p}): {rmse:.5f}")